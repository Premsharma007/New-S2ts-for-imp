Stop/Abort Functionality Implementation
Yes! Our pipeline has a proper stop/abort mechanism that works at any stage. Here's how it works:

1. Stop Button in UI:
python
# In main.py - UI section
with gr.Row():
    run_btn = gr.Button("🚀 Run Full Pipeline", variant="primary", size="lg")
    stop_btn = gr.Button("⏹️ Stop", variant="stop", size="lg")  # Red stop button
2. Global Stop Flag System:
python
# In main.py - Global stop mechanism
class PipelineController:
    def __init__(self):
        self._stop_requested = False
        self._current_process = None
    
    def request_stop(self):
        """Signal the pipeline to stop gracefully"""
        self._stop_requested = True
        if self._current_process:
            try:
                self._current_process.terminate()  # Force stop if needed
            except:
                pass
    
    def reset_stop_flag(self):
        """Reset the stop flag for a new run"""
        self._stop_requested = False
    
    def check_stop_requested(self):
        """Check if stop has been requested"""
        return self._stop_requested
    
    def set_current_process(self, process):
        """Track the current subprocess"""
        self._current_process = process

# Global controller
pipeline_controller = PipelineController()
3. Stop-Enabled Pipeline Execution:
python
def run_pipeline_with_stop_check(audio_path, enabled_langs, ...):
    # Reset stop flag at start
    pipeline_controller.reset_stop_flag()
    
    # ASR Stage with stop check
    if pipeline_controller.check_stop_requested():
        return "Pipeline stopped by user"
    
    asr_text, asr_time = run_asr(audio_path, 
        lambda p, m: update_progress(0, p, m))
    
    # Text Cleaning with stop check  
    if pipeline_controller.check_stop_requested():
        return "Pipeline stopped by user"
    
    cleaned_text, clean_time = clean_text(asr_text, ...)
    
    # Translation for each language with stop check
    for i, lang in enumerate(enabled_langs):
        if pipeline_controller.check_stop_requested():
            return f"Pipeline stopped during {lang} translation"
        
        translated, trans_time = translate_text(cleaned_text, lang, ...)
    
    # TTS for each language with stop check
    for i, lang in enumerate(enabled_langs):
        if pipeline_controller.check_stop_requested():
            return f"Pipeline stopped during {lang} TTS"
        
        tts_time = generate_tts(translated_texts[lang], ...)
    
    return "Pipeline completed successfully"
4. Integration with GUI Automation:
python
# In utils/gui_automation.py - Stop-aware methods
class GuiEngine:
    def send_and_get(self, prompt: str, text: str, target_lang: str = None, 
                    stop_check_callback=None) -> str:
        """
        Stop-aware translation method
        """
        # ... setup code ...
        
        while time.time() < deadline:
            # Check for stop request before each operation
            if stop_check_callback and stop_check_callback():
                self.stop()  # Close Chrome tab
                raise PipelineStoppedException("Translation stopped by user")
            
            # Continue normal operations...
5. Browser Tab Cleanup on Stop:
python
# Enhanced stop functionality
def stop_pipeline():
    """Completely stop the pipeline and cleanup"""
    pipeline_controller.request_stop()
    
    # Force close any Chrome tabs that might be open
    try:
        subprocess.run(["taskkill", "/f", "/im", "chrome.exe"], 
                      capture_output=True, timeout=10)
    except:
        pass
    
    # Force close ASR application if running
    try:
        subprocess.run(["taskkill", "/f", "/im", "OfflineTranscribe.exe"], 
                      capture_output=True, timeout=10)
    except:
        pass
    
    return "Pipeline stopped successfully"
6. UI Response to Stop:
python
# Stop button action
def on_stop_click():
    result = stop_pipeline()
    return {
        log: f"[{now_hhmmss()}] {result}",
        asr_progress: 0,
        clean_progress: 0, 
        translate_progress: 0,
        tts_progress: 0
    }

stop_btn.click(
    fn=on_stop_click,
    inputs=[],
    outputs=[log, asr_progress, clean_progress, translate_progress, tts_progress]
)
7. State Recovery After Stop:
When you stop the pipeline:

Current stage is marked as "stopped" in the manifest

Completed stages remain cached (ASR, cleaning, etc.)

Next run will continue from the stopped stage

No data loss for already completed work

Stop Scenarios Handled:
During ASR: Stops OfflineTranscribe.exe, closes any open windows

During Chrome Automation: Closes the current Chrome tab, kills if unresponsive

During Translation: Stops current translation, preserves previous ones

During TTS: Stops audio generation, keeps already generated files

Safety Features:
Graceful termination where possible

Force kill if graceful fails

State preservation of completed work

Clean resource cleanup (Chrome tabs, ASR app, etc.)

Visual feedback in UI showing stopped status

The Stop button is always active and will interrupt at any point in the pipeline! 🚨